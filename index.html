<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Station MÃ©tÃ©o</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Transition for background and text color */
            transition: background 1.5s ease-in-out, color 1.5s ease-in-out;
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            -webkit-backdrop-filter: blur(15px);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }
        select {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
        }
        select option {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            text-align: center;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-4xl mx-auto">
        <header class="mb-5 text-center">
            <h1 class="text-1xl font-bold tracking-wider"></h1>
            <div class="inline-flex items-center mt-2">
                <select id="city-selector" class="bg-transparent border-none text-3xl font-bold focus:outline-none p-2 appearance-none cursor-pointer text-center">
                </select>
                <div id="selector-arrow-container" class="ml-2 pointer-events-none"></div>
            </div>
            <p id="update-time" class="text-sm opacity-70">--</p>
        </header>
        <main id="weather-panel" class="glass-panel rounded-2xl p-6 min-h-[550px] flex items-center justify-center transition-opacity duration-500">
        </main>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const cities = [ { name: "Dourdan", lat: 48.53, lon: 2.01 }, { name: "Orsay", lat: 48.70, lon: 2.19 }, { name: "Saclay", lat: 48.71, lon: 2.16 }, { name: "Paris", lat: 48.85, lon: 2.35 }, { name: "Versailles", lat: 48.80, lon: 2.13 }, { name: "Cergy", lat: 49.03, lon: 2.06 } ];
            const WMO_CODES = { 0: { description: "Ciel dÃ©gagÃ©", emoji: "â˜€ï¸" }, 1: { description: "GÃ©nÃ©ralement dÃ©gagÃ©", emoji: "ðŸŒ¤ï¸" }, 2: { description: "Partiellement nuageux", emoji: "â›…ï¸" }, 3: { description: "Nuageux", emoji: "â˜ï¸" }, 45: { description: "Brouillard", emoji: "ðŸŒ«ï¸" }, 48: { description: "Brouillard givrant", emoji: "ðŸŒ«ï¸" }, 51: { description: "Bruine lÃ©gÃ¨re", emoji: "ðŸ’§" }, 53: { description: "Bruine modÃ©rÃ©e", emoji: "ðŸ’§" }, 55: { description: "Bruine dense", emoji: "ðŸ’§" }, 56: { description: "Bruine verglaÃ§ante", emoji: "ðŸ§Š" }, 57: { description: "Bruine verglaÃ§ante", emoji: "ðŸ§Š" }, 61: { description: "Pluie faible", emoji: "ðŸŒ¦ï¸" }, 63: { description: "Pluie modÃ©rÃ©e", emoji: "ðŸŒ§ï¸" }, 65: { description: "Pluie forte", emoji: "ðŸŒ§ï¸" }, 66: { description: "Pluie verglaÃ§ante", emoji: "ðŸ§Š" }, 67: { description: "Pluie verglaÃ§ante", emoji: "ðŸ§Š" }, 71: { description: "Neige faible", emoji: "ðŸŒ¨ï¸" }, 73: { description: "Neige modÃ©rÃ©e", emoji: "â„ï¸" }, 75: { description: "Neige forte", emoji: "â„ï¸" }, 77: { description: "Grains de neige", emoji: "â„ï¸" }, 80: { description: "Averses faibles", emoji: "ðŸŒ¦ï¸" }, 81: { description: "Averses modÃ©rÃ©es", emoji: "ðŸŒ§ï¸" }, 82: { description: "Averses violentes", emoji: "ðŸŒ§ï¸" }, 85: { description: "Averses de neige", emoji: "ðŸŒ¨ï¸" }, 86: { description: "Averses de neige", emoji: "ðŸŒ¨ï¸" }, 95: { description: "Orage", emoji: "â›ˆï¸" }, 96: { description: "Orage avec grÃªle", emoji: "â›ˆï¸" }, 99: { description: "Orage avec grÃªle", emoji: "â›ˆï¸" } };
            
            const weatherPanel = document.getElementById('weather-panel');
            const updateTimeElem = document.getElementById('update-time');
            const citySelector = document.getElementById('city-selector');
            let chartInstance = null;

            const isGloomyWeather = (code) => code >= 45;

            const calculateRgbForTemp = (temp) => {
                const colorStops = [
                    { temp: 0, color: [109, 213, 237] }, { temp: 15, color: [168, 224, 99] }, { temp: 30, color: [255, 65, 108] }
                ];
                let start = colorStops[0], end = colorStops[0];
                if (temp >= colorStops[colorStops.length - 1].temp) {
                    start = end = colorStops[colorStops.length - 1];
                } else if (temp > colorStops[0].temp) {
                    for (let i = 0; i < colorStops.length - 1; i++) {
                        if (temp >= colorStops[i].temp && temp <= colorStops[i + 1].temp) {
                            start = colorStops[i]; end = colorStops[i + 1]; break;
                        }
                    }
                }
                const ratio = Math.max(0, Math.min(1, (temp - start.temp) / (end.temp - start.temp || 1)));
                const r = Math.round(start.color[0] + (end.color[0] - start.color[0]) * ratio);
                const g = Math.round(start.color[1] + (end.color[1] - start.color[1]) * ratio);
                const b = Math.round(start.color[2] + (end.color[2] - start.color[2]) * ratio);
                return [r, g, b];
            };

            const getTextColorFromRgb = (rgb) => {
                const luminance = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
                return luminance > 140 ? 'black' : 'white';
            };

            const updateVisuals = (currentTemp, futureTemp, weatherCode) => {
                let textColor, startColor, endColor;

                if (isGloomyWeather(weatherCode)) {
                    textColor = 'white';
                    startColor = 'rgb(96, 108, 136)';
                    endColor = 'rgb(63, 76, 107)';
                } else {
                    const startRgb = calculateRgbForTemp(currentTemp);
                    const endRgb = calculateRgbForTemp(futureTemp);
                    textColor = getTextColorFromRgb(startRgb);
                    startColor = `rgb(${startRgb.join(',')})`;
                    endColor = `rgb(${endRgb.join(',')})`;
                }

                document.body.style.background = `linear-gradient(to right, ${startColor}, ${endColor})`;
                document.body.style.color = textColor;

                const arrowColor = textColor === 'white' ? '#ffffff' : '#000000';
                const arrowContainer = document.getElementById('selector-arrow-container');
                if (arrowContainer) {
                    arrowContainer.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 292.4 292.4" style="fill:${arrowColor};"><path d="M287 69.4a17.6 17.6 0 0 0-13-5.4H18.4c-5 0-9.3 1.8-12.9 5.4A17.6 17.6 0 0 0 0 82.2c0 5 1.8 9.3 5.4 12.9l128 127.9c3.6 3.6 7.8 5.4 12.8 5.4s9.2-1.8 12.8-5.4L287 95c3.5-3.5 5.4-7.8 5.4-12.8 0-5-1.9-9.4-5.4-13z"/></svg>`;
                }

                return textColor;
            };

            const populateCitySelector = () => {
                // Sort cities alphabetically by name
                cities.sort((a, b) => a.name.localeCompare(b.name));
                cities.forEach(city => citySelector.add(new Option(city.name, city.name)));
            };

            const displayWeatherForCity = async (cityName) => {
                showLoadingState(true);
                const city = cities.find(c => c.name === cityName);
                try {
                    const data = await getWeatherData(city.lat, city.lon);
                    
                    const now = new Date();
                    const currentIndex = data.hourly.time.findIndex(t => new Date(t) > now);
                    const futureIndex = Math.min(currentIndex + 6, data.hourly.time.length - 1);
                    const futureTemp = data.hourly.temperature_2m[futureIndex];
                    
                    const textColor = updateVisuals(data.current.temperature_2m, futureTemp, data.current.weather_code);

                    weatherPanel.innerHTML = createWeatherContent(data);
                    renderChart(data.daily, textColor);
                } catch (error) {
                    console.error(error);
                    weatherPanel.innerHTML = createErrorContent(city.name);
                } finally {
                    showLoadingState(false);
                    updateTimeElem.textContent = `DonnÃ©es mises Ã  jour Ã  ${new Date().toLocaleTimeString('fr-FR')}`;
                }
            };
            
            const getWeatherData = async (lat, lon) => {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m&hourly=temperature_2m,weather_code&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=Europe/Paris&forecast_days=7`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
                return await response.json();
            };

            const createWeatherContent = (data) => {
                const { current, hourly, daily } = data;
                const weatherInfo = getWeatherInfo(current.weather_code);
                return `
                    <div class="w-full">
                        <div class="flex justify-between items-center">
                            <p class="text-5xl font-bold">${Math.round(current.temperature_2m)}Â°C</p>
                            <div class="text-right">
                                <p class="text-7xl -mt-4">${weatherInfo.emoji}</p>
                                <p class="capitalize text-xl opacity-80">${weatherInfo.description}</p>
                            </div>
                        </div>
                        <div class="grid grid-cols-3 gap-4 text-center opacity-90 my-6">
                            <div><p class="font-bold text-2xl">${Math.round(current.apparent_temperature)}Â°</p><p class="text-base opacity-70">Ressenti</p></div>
                            <div><p class="font-bold text-2xl">${current.relative_humidity_2m}%</p><p class="text-base opacity-70">HumiditÃ©</p></div>
                            <div><p class="font-bold text-2xl">${Math.round(current.wind_speed_10m)}</p><p class="text-base opacity-70">km/h</p></div>
                        </div>
                        <div class="border-t border-current/20 pt-4">
                            <h3 class="text-center text-base font-semibold opacity-80 mb-2">PROCHAINES HEURES</h3>
                            <div class="flex justify-around">
                                ${generateHourlyForecast(hourly)}
                            </div>
                        </div>
                        <div class="mt-6 border-t border-current/20 pt-4">
                            <h3 class="text-center text-base font-semibold opacity-80 mb-2">PROCHAINS JOURS</h3>
                            <div>
                                <div class="h-32"><canvas id="forecastChart"></canvas></div>
                                <div class="grid grid-cols-7 text-center mt-1 px-2">
                                    ${generateDailyForecastLabelsAndIcons(daily)}
                                </div>
                            </div>
                        </div>
                    </div>`;
            };
            
            const generateHourlyForecast = (hourly) => {
                const now = new Date();
                const startIndex = hourly.time.findIndex(t => new Date(t) > now);
                if (startIndex === -1) return `<p class="text-sm opacity-70">Pas de prÃ©visions.</p>`;
                let forecastHTML = '';
                for(let i = startIndex; i < startIndex + 7 && i < hourly.time.length; i++) {
                    const date = new Date(hourly.time[i]);
                    const weatherInfo = getWeatherInfo(hourly.weather_code[i]);
                    forecastHTML += `
                        <div class="text-center">
                            <p class="text-base opacity-80">${date.getHours()}h</p>
                            <p class="text-3xl my-1">${weatherInfo.emoji}</p>
                            <p class="font-bold text-lg">${Math.round(hourly.temperature_2m[i])}Â°</p>
                        </div>`;
                }
                return forecastHTML;
            };

            const generateDailyForecastLabelsAndIcons = (daily) => {
                let forecastHTML = '';
                const formatter = new Intl.DateTimeFormat('fr-FR', { weekday: 'short' });
                daily.time.forEach((time, index) => {
                    const dayLabel = formatter.format(new Date(time));
                    const weatherInfo = getWeatherInfo(daily.weather_code[index]);
                    forecastHTML += `
                        <div>
                            <p class="text-base opacity-80">${dayLabel}</p>
                            <p class="text-2xl mt-1">${weatherInfo.emoji}</p>
                        </div>
                    `;
                });
                return forecastHTML;
            };

            const renderChart = (daily, textColor) => {
                const ctx = document.getElementById('forecastChart').getContext('2d');
                const formatter = new Intl.DateTimeFormat('fr-FR', { weekday: 'short' });
                if (chartInstance) {
                    chartInstance.destroy();
                }
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: daily.time.map(t => formatter.format(new Date(t))),
                        datasets: [{
                            label: 'Max',
                            data: daily.temperature_2m_max,
                            borderColor: textColor,
                            tension: 0.4,
                            pointRadius: 0 // This hides the markers
                        }, {
                            label: 'Min',
                            data: daily.temperature_2m_min,
                            borderColor: textColor === 'white' ? 'rgba(255, 255, 255, 0.4)' : 'rgba(0, 0, 0, 0.4)',
                            tension: 0.4,
                            pointRadius: 0 // This hides the markers
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                display: true,
                                grid: {
                                    color: textColor === 'white' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)'
                                },
                                ticks: {
                                    color: textColor
                                }
                            },
                            x: {
                                grid: {
                                    display: false
                                },
                                ticks: {
                                    display: false 
                                }
                            }
                        }
                    }
                });
            };

            const getWeatherInfo = (code) => WMO_CODES[code] || { description: "Inconnu", emoji: "ðŸŒ" };
            const showLoadingState = (isLoading) => { weatherPanel.style.opacity = isLoading ? '0.5' : '1'; };
            const createErrorContent = (city) => `<div class="text-center text-red-500">Impossible de charger les donnÃ©es pour ${city}.</div>`;

            const init = () => {
                populateCitySelector();
                // Set default city to Dourdan
                const defaultCity = "Dourdan";
                citySelector.value = defaultCity;
                displayWeatherForCity(defaultCity);
                
                citySelector.addEventListener('change', (e) => displayWeatherForCity(e.target.value));
            };

            init();
        });
    </script>
</body>
</html>