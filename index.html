<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Station M√©t√©o</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Transition for background and text color */
            transition: background 1.5s ease-in-out, color 1.5s ease-in-out;
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            -webkit-backdrop-filter: blur(15px);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }
        select {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
        }
        select option {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            text-align: center;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 bg-gray-800">
    <div class="w-full max-w-4xl mx-auto">
        <header class="mb-5 text-center">
            <h1 class="text-1xl font-bold tracking-wider"></h1>
            <div class="inline-flex items-center mt-2">
                <select id="city-selector" class="bg-transparent border-none text-3xl font-bold focus:outline-none p-2 appearance-none cursor-pointer text-center">
                </select>
                <div id="selector-arrow-container" class="ml-2 pointer-events-none"></div>
            </div>
            <p id="update-time" class="text-sm opacity-70">--</p>
            <div id="error-message-container" class="text-yellow-400 font-semibold text-sm mt-1 h-5"></div>
        </header>
        <main id="weather-panel" class="glass-panel rounded-2xl p-6 min-h-[550px] flex items-center justify-center transition-opacity duration-500">
            <!-- Weather content will be injected here -->
        </main>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DATA & CONFIGURATION ---
            const cities = [ { name: "Local" }, { name: "Dourdan", lat: 48.53, lon: 2.01 }, { name: "Orsay", lat: 48.70, lon: 2.19 }, { name: "Saclay", lat: 48.71, lon: 2.16 }, { name: "Paris", lat: 48.85, lon: 2.35 }, { name: "Versailles", lat: 48.80, lon: 2.13 }, { name: "Cergy", lat: 49.03, lon: 2.06 } ];
            const WMO_CODES = { 0: { description: "Ciel d√©gag√©", emoji: "‚òÄÔ∏è" }, 1: { description: "G√©n√©ralement d√©gag√©", emoji: "üå§Ô∏è" }, 2: { description: "Partiellement nuageux", emoji: "‚õÖÔ∏è" }, 3: { description: "Nuageux", emoji: "‚òÅÔ∏è" }, 45: { description: "Brouillard", emoji: "üå´Ô∏è" }, 48: { description: "Brouillard givrant", emoji: "üå´Ô∏è" }, 51: { description: "Bruine l√©g√®re", emoji: "üíß" }, 53: { description: "Bruine mod√©r√©e", emoji: "üíß" }, 55: { description: "Bruine dense", emoji: "üíß" }, 56: { description: "Bruine vergla√ßante", emoji: "üßä" }, 57: { description: "Bruine vergla√ßante", emoji: "üßä" }, 61: { description: "Pluie faible", emoji: "üå¶Ô∏è" }, 63: { description: "Pluie mod√©r√©e", emoji: "üåßÔ∏è" }, 65: { description: "Pluie forte", emoji: "üåßÔ∏è" }, 66: { description: "Pluie vergla√ßante", emoji: "üßä" }, 67: { description: "Pluie vergla√ßante", emoji: "üßä" }, 71: { description: "Neige faible", emoji: "üå®Ô∏è" }, 73: { description: "Neige mod√©r√©e", emoji: "‚ùÑÔ∏è" }, 75: { description: "Neige forte", emoji: "‚ùÑÔ∏è" }, 77: { description: "Grains de neige", emoji: "‚ùÑÔ∏è" }, 80: { description: "Averses faibles", emoji: "üå¶Ô∏è" }, 81: { description: "Averses mod√©r√©es", emoji: "üåßÔ∏è" }, 82: { description: "Averses violentes", emoji: "üåßÔ∏è" }, 85: { description: "Averses de neige", emoji: "üå®Ô∏è" }, 86: { description: "Averses de neige", emoji: "üå®Ô∏è" }, 95: { description: "Orage", emoji: "‚õàÔ∏è" }, 96: { description: "Orage avec gr√™le", emoji: "‚õàÔ∏è" }, 99: { description: "Orage avec gr√™le", emoji: "‚õàÔ∏è" } };
            
            // --- DOM ELEMENTS ---
            const weatherPanel = document.getElementById('weather-panel');
            const updateTimeElem = document.getElementById('update-time');
            const citySelector = document.getElementById('city-selector');
            const errorMessageContainer = document.getElementById('error-message-container');
            let chartInstance = null;

            // --- CORE LOGIC ---

            /**
             * Main function to fetch and display weather for a given city.
             * Handles geolocation and fallbacks gracefully.
             * @param {string} cityName - The name of the city from the selector.
             */
            const displayWeatherForCity = async (cityName) => {
                errorMessageContainer.innerHTML = '';
                showLoadingState(true);
                let cityData;

                // Step 1: Determine the city's coordinates.
                if (cityName === "Local") {
                    try {
                        const response = await fetch('https://ipapi.co/json/');
                        if (!response.ok) throw new Error('IP API response was not ok.');
                        const ipData = await response.json();
                        if (ipData.error) throw new Error(ipData.reason);
                        
                        cityData = { name: ipData.city, lat: ipData.latitude, lon: ipData.longitude };
                        const localOption = Array.from(citySelector.options).find(option => option.value === 'Local');
                        if (localOption) {
                            localOption.text = cityData.name; // Update 'Local' to actual city name
                        }
                    } catch (geoError) {
                        console.warn("Geolocation failed, falling back to Paris.", geoError);
                        errorMessageContainer.innerHTML = 'G√©olocalisation impossible. Affichage pour Paris.';
                        citySelector.value = "Paris";
                        cityData = cities.find(c => c.name === "Paris");
                    }
                } else {
                    cityData = cities.find(c => c.name === cityName);
                }

                // Step 2: Fetch and render weather using the determined cityData.
                try {
                    if (!cityData || typeof cityData.lat === 'undefined' || typeof cityData.lon === 'undefined') {
                        throw new Error(`Invalid city data for '${cityName}'.`);
                    }

                    const data = await getWeatherData(cityData.lat, cityData.lon);
                    
                    const now = new Date();
                    const currentIndex = data.hourly.time.findIndex(t => new Date(t) > now);
                    const futureIndex = Math.min(currentIndex + 6, data.hourly.time.length - 1);
                    const futureTemp = data.hourly.temperature_2m[futureIndex];
                    const textColor = updateVisuals(data.current.temperature_2m, futureTemp, data.current.weather_code);
                    
                    weatherPanel.innerHTML = createWeatherContent(data);
                    renderChart(data.daily, textColor);

                } catch (weatherError) {
                    console.error(`Failed to display weather for ${cityData?.name || cityName}`, weatherError);
                    weatherPanel.innerHTML = createErrorContent(cityData?.name || cityName);
                    document.body.style.background = `linear-gradient(to right, #6c757d, #495057)`;
                    document.body.style.color = 'white';
                } finally {
                    showLoadingState(false);
                    updateTimeElem.textContent = `Donn√©es mises √† jour √† ${new Date().toLocaleTimeString('fr-FR')}`;
                }
            };
            
            /**
             * Fetches weather data from the Open-Meteo API.
             * @param {number} lat - Latitude
             * @param {number} lon - Longitude
             * @returns {Promise<object>} - The weather data JSON.
             */
            const getWeatherData = async (lat, lon) => {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m&hourly=temperature_2m,weather_code&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=Europe/Paris&forecast_days=7`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
                return await response.json();
            };

            // --- UI & VISUALS ---

            const isGloomyWeather = (code) => code >= 45;

            const calculateRgbForTemp = (temp) => {
                const colorStops = [ { temp: 0, color: [109, 213, 237] }, { temp: 15, color: [168, 224, 99] }, { temp: 30, color: [255, 65, 108] } ];
                let start = colorStops[0], end = colorStops[0];
                if (temp >= colorStops[colorStops.length - 1].temp) { start = end = colorStops[colorStops.length - 1]; } 
                else if (temp > colorStops[0].temp) {
                    for (let i = 0; i < colorStops.length - 1; i++) {
                        if (temp >= colorStops[i].temp && temp <= colorStops[i + 1].temp) { start = colorStops[i]; end = colorStops[i + 1]; break; }
                    }
                }
                const ratio = Math.max(0, Math.min(1, (temp - start.temp) / (end.temp - start.temp || 1)));
                const r = Math.round(start.color[0] + (end.color[0] - start.color[0]) * ratio);
                const g = Math.round(start.color[1] + (end.color[1] - start.color[1]) * ratio);
                const b = Math.round(start.color[2] + (end.color[2] - start.color[2]) * ratio);
                return [r, g, b];
            };

            const getTextColorFromRgb = (rgb) => {
                const luminance = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
                return luminance > 140 ? 'black' : 'white';
            };

            const updateVisuals = (currentTemp, futureTemp, weatherCode) => {
                let textColor, startColor, endColor;
                if (isGloomyWeather(weatherCode)) {
                    textColor = 'white';
                    startColor = 'rgb(96, 108, 136)';
                    endColor = 'rgb(63, 76, 107)';
                } else {
                    const startRgb = calculateRgbForTemp(currentTemp);
                    const endRgb = calculateRgbForTemp(futureTemp);
                    textColor = getTextColorFromRgb(startRgb);
                    startColor = `rgb(${startRgb.join(',')})`;
                    endColor = `rgb(${endRgb.join(',')})`;
                }

                document.body.style.background = `linear-gradient(to right, ${startColor}, ${endColor})`;
                document.body.style.color = textColor;
                const arrowColor = textColor === 'white' ? '#ffffff' : '#000000';
                const arrowContainer = document.getElementById('selector-arrow-container');
                if (arrowContainer) {
                    arrowContainer.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 292.4 292.4" style="fill:${arrowColor};"><path d="M287 69.4a17.6 17.6 0 0 0-13-5.4H18.4c-5 0-9.3 1.8-12.9 5.4A17.6 17.6 0 0 0 0 82.2c0 5 1.8 9.3 5.4 12.9l128 127.9c3.6 3.6 7.8 5.4 12.8 5.4s9.2-1.8 12.8-5.4L287 95c3.5-3.5 5.4-7.8 5.4-12.8 0-5-1.9-9.4-5.4-13z"/></svg>`;
                }
                return textColor;
            };

            const populateCitySelector = () => {
                cities.sort((a, b) => {
                    if (a.name === "Local") return -1;
                    if (b.name === "Local") return 1;
                    return a.name.localeCompare(b.name);
                });
                citySelector.innerHTML = '';
                cities.forEach(city => citySelector.add(new Option(city.name, city.name)));
            };

            const createWeatherContent = (data) => {
                const { current, hourly, daily } = data;
                const weatherInfo = getWeatherInfo(current.weather_code);
                return `
                    <div class="w-full">
                        <div class="flex justify-between items-center">
                            <p class="text-5xl font-bold">${Math.round(current.temperature_2m)}¬∞C</p>
                            <div class="text-right">
                                <p class="text-7xl -mt-4">${weatherInfo.emoji}</p>
                                <p class="capitalize text-xl opacity-80">${weatherInfo.description}</p>
                            </div>
                        </div>
                        <div class="grid grid-cols-3 gap-4 text-center opacity-90 my-6">
                            <div><p class="font-bold text-2xl">${Math.round(current.apparent_temperature)}¬∞</p><p class="text-base opacity-70">Ressenti</p></div>
                            <div><p class="font-bold text-2xl">${current.relative_humidity_2m}%</p><p class="text-base opacity-70">Humidit√©</p></div>
                            <div><p class="font-bold text-2xl">${Math.round(current.wind_speed_10m)}</p><p class="text-base opacity-70">km/h</p></div>
                        </div>
                        <div class="border-t border-current/20 pt-4">
                            <h3 class="text-center text-base font-semibold opacity-80 mb-2">PROCHAINES HEURES</h3>
                            <div class="flex justify-around">
                                ${generateHourlyForecast(hourly)}
                            </div>
                        </div>
                        <div class="mt-6 border-t border-current/20 pt-4">
                            <h3 class="text-center text-base font-semibold opacity-80 mb-2">PROCHAINS JOURS</h3>
                            <div>
                                <div class="h-32"><canvas id="forecastChart"></canvas></div>
                                <div class="grid grid-cols-7 text-center mt-1 px-2">
                                    ${generateDailyForecastLabelsAndIcons(daily)}
                                </div>
                            </div>
                        </div>
                    </div>`;
            };
            
            const generateHourlyForecast = (hourly) => {
                const now = new Date();
                const startIndex = hourly.time.findIndex(t => new Date(t) > now);
                if (startIndex === -1) return `<p class="text-sm opacity-70">Pas de pr√©visions.</p>`;
                let forecastHTML = '';
                for(let i = startIndex; i < startIndex + 7 && i < hourly.time.length; i++) {
                    const date = new Date(hourly.time[i]);
                    const weatherInfo = getWeatherInfo(hourly.weather_code[i]);
                    forecastHTML += `
                        <div class="text-center">
                            <p class="text-base opacity-80">${date.getHours()}h</p>
                            <p class="text-3xl my-1">${weatherInfo.emoji}</p>
                            <p class="font-bold text-lg">${Math.round(hourly.temperature_2m[i])}¬∞</p>
                        </div>`;
                }
                return forecastHTML;
            };

            const generateDailyForecastLabelsAndIcons = (daily) => {
                let forecastHTML = '';
                const formatter = new Intl.DateTimeFormat('fr-FR', { weekday: 'short' });
                daily.time.forEach((time, index) => {
                    const dayLabel = formatter.format(new Date(time));
                    const weatherInfo = getWeatherInfo(daily.weather_code[index]);
                    forecastHTML += `
                        <div>
                            <p class="text-base opacity-80">${dayLabel}</p>
                            <p class="text-2xl mt-1">${weatherInfo.emoji}</p>
                        </div>
                    `;
                });
                return forecastHTML;
            };

            const renderChart = (daily, textColor) => {
                const ctx = document.getElementById('forecastChart').getContext('2d');
                if (chartInstance) { chartInstance.destroy(); }
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: daily.time.map(t => new Intl.DateTimeFormat('fr-FR', { weekday: 'short' }).format(new Date(t))),
                        datasets: [{
                            label: 'Max', data: daily.temperature_2m_max, borderColor: textColor, tension: 0.4, pointRadius: 0
                        }, {
                            label: 'Min', data: daily.temperature_2m_min, borderColor: textColor === 'white' ? 'rgba(255, 255, 255, 0.4)' : 'rgba(0, 0, 0, 0.4)', tension: 0.4, pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { display: true, grid: { color: textColor === 'white' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)' }, ticks: { color: textColor } },
                            x: { grid: { display: false }, ticks: { display: false } }
                        }
                    }
                });
            };
            
            // --- HELPER FUNCTIONS ---

            const getWeatherInfo = (code) => WMO_CODES[code] || { description: "Inconnu", emoji: "üåç" };
            
            /**
             * THIS FUNCTION IS FIXED
             * Manages the loading state UI.
             * @param {boolean} isLoading - Whether the app is currently loading.
             */
            const showLoadingState = (isLoading) => { 
                if (isLoading) {
                    weatherPanel.innerHTML = `<div class="text-center p-8">Chargement...</div>`;
                    weatherPanel.style.opacity = '0.5';
                } else {
                    // Only restore opacity. Do not touch innerHTML, as it would
                    // clear the newly rendered chart.
                    weatherPanel.style.opacity = '1'; 
                }
            };
            const createErrorContent = (city) => `<div class="text-center font-semibold p-8">Impossible de charger les donn√©es pour ${city}.<br>Veuillez r√©essayer plus tard.</div>`;

            /**
             * Initializes the application.
             */
            const init = () => {
                populateCitySelector();
                const defaultCity = "Local";
                citySelector.value = defaultCity;
                displayWeatherForCity(defaultCity);
                citySelector.addEventListener('change', (e) => displayWeatherForCity(e.target.value));
            };

            // --- START THE APP ---
            init();
        });
    </script>
</body>
</html>
